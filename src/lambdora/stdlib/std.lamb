; std.lamb â€” Lambdora Standard Library

; === Basic helpers ===
(define id       (lambda x. x))
(define const    (lambda x. (lambda y. x)))

; === Predicates ===
(define isZero   (lambda n. (= n 0)))

; === Arithmetic shortcuts ===
(define double   (lambda x. (+ x x)))
(define triple   (lambda x. (+ x (double x))))

; === Factorial (tail-recursive) ===
(define factHelper
  (lambda i. (lambda acc.
    (if (= i 0)
        acc
        (factHelper (- i 1) (* acc i))))))

(define fact (lambda n. (factHelper n 1)))

; === Fibonacci ===
(define fib
  (lambda n.
    (if (< n 2)
        n
        (+ (fib (- n 1))
           (fib (- n 2))))))

; === Fold and variants ===
(define foldlHelper
  (lambda f. (lambda acc. (lambda lst.
    (if (isNil lst)
        acc
        (foldlHelper f (f acc (head lst)) (tail lst)))))))

(define foldl
  (lambda f. (lambda acc. (lambda lst.
    (foldlHelper f acc lst)))))

; === Basic list operations ===
(define reverse
  (lambda lst. ((foldl (lambda acc. (lambda x. (cons x acc))) nil) lst)))

; === Range generation (tail-recursive) ===
(define rangeHelper
  (lambda i. (lambda acc.
    (if (< i 0)
        acc
        (rangeHelper (- i 1) (cons i acc))))))

(define range
  (lambda n.
    (rangeHelper (- n 1) nil)))

; === List operations ===
(define map
  (lambda f. (lambda lst.
    (if (isNil lst)
        nil
        (cons (f (head lst))
              ((map f) (tail lst)))))))

(define filter
  (lambda pred. (lambda lst.
    (if (isNil lst)
        nil
        (let h (head lst)
          (let t ((filter pred) (tail lst))
            (if (pred h)
                (cons h t)
                t)))))))

(define length
  (lambda lst. ((foldl (lambda n. (lambda _. (+ n 1))) 0) lst)))

(define sum
  (lambda lst. ((foldl (lambda a. (lambda b. (+ a b))) 0) lst)))

; === List generation ===
(define ones
  (lambda n.
    ((foldl (lambda acc. (lambda _. (cons 1 acc))) nil) (range n))))

; === Simple sums of ones ===
(define sumOnes
  (lambda n.
    ((foldl (lambda a. (lambda b. (+ a b))) 0) (ones n))))

; === Control-flow macros ===
(defmacro when   (cond body)       `(if ,cond ,body nil))
(defmacro unless (cond body)       `(if (not ,cond) ,body nil))
(defmacro begin  (a b)             `(let __ignore ,a ,b))

; === Short-circuit logic ===
(defmacro and2 (a b)               `(if ,a ,b false))
(defmacro or2  (a b)               `(if ,a true ,b))

; === Let-binding macros ===
(defmacro let  (var val body)      `((lambda ,var . ,body) ,val))
(defmacro let2 (x y xval yval body)
  `((lambda ,x . ((lambda ,y . ,body) ,yval)) ,xval))

; === Cond (two branches only for now) ===
(defmacro cond (a b c d)           `(if ,a ,b (if ,c ,d nil)))
